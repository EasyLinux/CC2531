# -*- coding: UTF-8 -*-
#/**
# * Software name: CC2531
# * Version: 0.1.0
# * Library to drive TI CC2531 802.15.4 dongle to monitor channels
# * Copyright (C) 2013 Benoit Michau, ANSSI.
# *
# * This program is free software; you can redistribute it and/or modify
# * it under the terms of the CeCILL-B license as published here:
# * http://www.cecill.info/licences/Licence_CeCILL-B_V1-en.html
# *
# *--------------------------------------------------------
# * File Name : decoder.py
# * Created : 2013-11-13
# * Authors : Benoit Michau, ANSSI
# *--------------------------------------------------------
# */
#!/usr/bin/python2
#
###
# 802.15.4 monitor based on Texas Instruments CC2531 USB dongle
#
# uses libusb1
# http://www.libusb.org/
# and python-libusb1
# https://github.com/vpelletier/python-libusb1/
###
#
# This is a decoder that takes pcap file generated by receivers (see receiver.py)
# as run by the sniffer.py program,
# and prints the details of each 802.15.4 frame retrieved by CC2531 dongle.
# It requires libmich and its IEEE802154 format descriptor.
#

import sys
from time import strftime, localtime
from libmich.formats import pcap
from libmich.formats import IEEE802154
from libmich.core.element import Int

IEEE802154.IEEE802154.PHY_INCL = False
IEEE802154.IEEE802154.FCS_INCL = False

Tags = {
    0x01 : 'channel',
    0x02 : 'time',
    0x03 : 'position',
    0x10 : 'TI_PSD with 802.15.4 frame',
    0x20 : '802.15.4 frame',
    }

def process_pcap(pcap_file='test.pcap'):
    #
    try:
        s = open(pcap_file, 'rb').read()
    except IOError:
        print('ERROR: cannot open file')
        return
    print('pcap file length: %i bytes\n' % len(s))
    #
    Int._endian = 'little'
    glob = pcap.Global()
    glob.parse(s)
    s = s[len(glob):]
    print('pcap global header:\n%s\n' % glob.show())
    #
    while len(s) > 16:
        s = chk_record(s)

def chk_record(s):
    #
    Int._endian = 'little'
    rec = pcap.Record()
    rec.parse(s)
    l = rec.incl_len()
    process_packet(s[16:16+l])
    s = s[16+l:]
    return s

def process_packet(buf):
    #
    # go directly after the UDP header
    # Ethernet: 14 bytes
    # IPv4: 20 bytes
    # UDP: 8 bytes
    # after checking dest port is 2154
    #
    dstport = (ord(buf[36])<<8) + ord(buf[37])
    if dstport != 2154:
        return
    #
    buf = buf[42:]
    if len(buf) > 40:
        print('[+] packet received:')
    else:
        print('[-] packet too short... strange')
        return
    while len(buf) > 2:
        buf = chk_tlv(buf)
    print(30*'-')
    
def chk_tlv(buf):
    #
    Int._endian = 'big'
    #
    T, L = ord(buf[0]), ord(buf[1])
    if L:
        V = buf[2:2+L]
        # TODO: most of the parsing below is done in an insecure way
        if T == 1:
            print('channel: %i' % ord(V[0]))
        elif T == 2:
            print('time: %s' % strftime('%Y-%m-%d %H:%M:%S', localtime(float(V))))
        elif T == 3:
            print('position (GPRMC): %s' % V)
        elif T == 0x10:
            psd = IEEE802154.TI_PSD()
            psd.parse(V)
            print('TI PSD structure:\n%s' % psd.show())
            data = psd.Data()
            if len(data) >= 2:
                frame = IEEE802154.IEEE802154()
                try:
                    frame.parse(psd.Data())
                    print('IEEE 802.15.4 frame:\n%s' % frame.show())
                except:
                    pass
        elif T == 0x20:
            frame = IEEE802154.IEEE802154()
            frame.parse(V)
            print('IEEE 802.15.4 frame:\n%s' % frame.show())
    #
    return buf[2+L:]

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('%s:    please provide path to captured pcap file' % sys.argv[0])
        exit()
    process_pcap( sys.argv[1] )
